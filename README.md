# inflearn_HTTP_basic

<h3>IP(인터넷 프로토콜)</h3>
지정 IP 주소에 데이터를 전달(패킷 단위로)

패킷 정보 -> 출발지/목적지 IP, 기타정보

<h4>IP의 한계</h4>

- 비연결성: 패킷 받을 대상이 없거나 서비스 불능 상태여도 패킷을 전송함(대상 서버가 패킷을 받을 수 있는 상태인지 알 수 없음)
- 비신뢰성: 중간에 패킷이 사라지면?, 패킷이 순서대로 안오면? 에 대한 대응이 불가능(중간 서버에 문제가 생겨서 패킷 소실되는 상황, 패킷이 1500바이트정도 이상이면 여러 패킷으로 나눠서 보내는데 순서가 보장되지 않는 문제 -> TCP프로토콜로 해결됨)
- 프로그램 구분: 같은 IP 사용하는 서버에서 통신하는 애플리케이션이 여러개면?

----------------------------------------------------------------------------------
<h3>TCP, UDP</h3>
IP 4계층 [네트워크 인터페이스 계층 - 인터넷 계층 - 전송 계층 - 애플리케이션 계층]

<h4>TCP(전송 제어 프로토콜)</h4>
- 연결지향 - TCP 3 way handshake(가상연결)
- 데이터 전달 보증
- 순서 보장 
-> 신뢰할 수 있는 프로토콜

<h5>3 way handshack</h5>
클라 -> 서버 SYN
서버 -> 클라 SYN+ACK
클라 -> 서버 ACK
데이터 전송
(SYN: 접속요청, ACK: 요청수락 / ACK와 함께 데이터 전송가능)

TCP 3 way handshack는 가상연결. 실제로 연결된 것이 아니라 논리적으로 연결된 것

<h4>UDP(사용자 데이터그램 프로토콜)</h4>
기능이 없다. 비유하자면 그냥 빈 도화지
연결지향X 데이터전달보장X 순서보장X
하지만 단순하고 빠름, IP와 똑같은데 PORT, 체크섬만 추가

----------------------------------------------------------------------------------
<h3>PORT</h3>
클라이언트가 한번에 여러 서버와 통신해야한다면
-> 패킷들이 어디서 사용할건지, 어디서 온건지 어떻게 구분할거? -> PORT

TCP/IP 패킷 안에 출발지/목적지 PORT 정보 포함됨
(네트워크 상에서 특정 프로그램이나 서비스와 통신할 수 있는 문의 역할을 함)

포트 범위 0~65535
잘 알려진 포트: 0~1023(사용하지 않는 것이 좋음)
ex) HTTP-80 / HTTPS-443

----------------------------------------------------------------------------------
<h3>DNS</h3>
IP는 기억하기 어려움 + 변경 가능함
-> DNS(Domain Name System)
DNS 서버에 {도메인명:IP} 같이 쌍으로 보관되어서 도메인 명으로 요청하면 IP를 받음

----------------------------------------------------------------------------------
<h3>URI(Uniform Resource Identifier)</h3>

URI, URL, URN
- URI: 가장 큰 범위, URL과 URN을 포함, 리소스를 식별하는 문자열 형식의 표준
- URL: Resource Locator, 리소스의 위치를 나타냄
- URN: Resource Name, 리소스의 이름을 나타냄
URN 이름만으로 실제 리소스를 찾을 수 있는 방법이 보편화되지 않음 -> 거의 URL만 사용됨

<h4>URL 기본 문법</h4>
scheme://[userInfo@]host[:port][/path][?query][#fragment]
https://www.google.com:443/search?q=hello%hl=ko

scheme: 프로토콜(http80, http443), 포트는 생략 가능
userInfo: URL에 사용자 정보를 포함하여 인증, 거의 사용되지 않음
host: 호스트명, 도메인명이나 IP를 직접 사용
port: 보통 생략됨, 접속 포트
path: 리소스 경로, 계층적 구조(/home/file1.png)
query: key=value형태, ?로 시작, &로 추가 가능
(?keyA=valueA&keyB=valueB), query parameter, query string으로 불림, 웹 서버에 제공하는 파라미터
fragment: html 내부 북마크 등에 사용, 잘 사용되지 않음, 서버에 전송하는 정보가 아님

----------------------------------------------------------------------------------
<h3>웹 브라우저 요청 흐름</h3>
HTTP 메시지 전송
웹 브라우저가 HTTP 메시지 생성 
-> SOCKET 라이브러리를 통해 전달 
-> TCP/IP 패킷 생성, HTTP 메시지를 포함, 패킷[출발지IP, PORT, 목적지 IP, PORT]

----------------------------------------------------------------------------------
<h3>HTTP(HyperText Transfer Protocol</h3>
거의 모든 형태의 데이터를 HTTP 메시지에 담아 전송

<HTTP의 특징>
- 클라이언트 서버 구조
- stateless
- 비연결성
- 단순함, 확장가능

<h4>클라이언트 서버 구조</h4>
클라이언트가 요청하고 서버가 응답, Request Response 구조
클라이언트에서는 UI, 사용성 / 서버에서는 비지니스 로직과 데이터 관리
양쪽의 독립적인 개발이 가능해짐

<h4>stateless(무상태 프로토콜)</h4>
서버가 클라이언트의 상태를 보존하지 않음
서버의 확장성이 높지만, 클라이언트가 추가 데이터를 전송해야 함
스케일 아웃 -> 수평 확장이 유리

* 한계점: 로그인이 필요없는 단순한 서비스 소개 화면에서는 사용 가능하지만, 로그인이 필요한 경우 로그인했다는 상태를 유지해야 함
  stateful은 꼭 필요한 경우 최소한으로 사용함
- stateless와 stateful의 차이
  stateless: 점원이 바뀌어도 됨. 갑자기 클라이언트 요청이 증가해도 서버를 대거 투입 가능 -> 응답 서버를 쉽게 바꿈 -> 무한한 서버 증설 가능
  stateful: 중간에 점원이 바뀌면 정보가 초기화됨

<h4>비연결성(connectionless)</h4>
여러 클라이언트가 한 서버에 요청했을 때 연결을 계속 유지한다면, 불필요한 자원 소모가 발생함
-> 요청을 주고받을 때만 연결을 유지함 -> 비연결성
HTTP는 기본적으로 연결을 유지하지 않는 모델
서버를 매우 효율적으로 사용할 수 있음

* 단점: TCP/IP 연결을 매 번 새로 맺어야 함 -> 3 way handshack에 걸리는 시간이 추가됨
  웹 브라우저를 요청하면 HTML뿐 아니라 CSS, JS, 이미지 등을 새로 다운로드 함 -> 각각의 요청마다 연결과 종료 반복
  -> HTTP 지속 연결(Persistent Connections)로 해결
  HTTP/2와 HTTP/3에서는 더 많은 최적화가 되어있음

----------------------------------------------------------------------------------
<h3>HTTP 메시지</h3>
- HTTP 메시지 구조
start-line
header
empty line(CRLF)
message body

----------------------------------------------------------------------------------
<h3>HTTP 주요 메서드</h3>
GET: 리소스 조회
POST: 요청 데이터 처리, 주로 등록에 사용
PUT: 리소스 완전 대체, 해당 리소스 없으면 생성
PATCH: 리소스 부분 변경
DELETE: 리소스 삭제

<h4>GET</h4>
리소스 조회, 서버에 전달하려는 데이터를 query를 통해 전달(query parameter, query string)
메시지 바디를 사용해서 전달도 가능하지만, 지원하지 않는 곳이 많아 권장하지 않음

<h4>POST</h4>
요청 데이터 처리, 메시지 바디를 통해 서버로 요청 데이터 전달
주로 전달된 데이터로 신규 리소스 등록, 프로세스 처리에 사용

<h4>PUT</h4>
리소스를 완전 대체, 리소스가 없으면 생성 -> 덮어쓰기
POST와의 차이 -> 클라이언트가 리소스의 위치를 알고 URI를 지정
PUT은 일부 필드만 변경할 수 없음

<h4>PATCH</h4>
리소스를 부분 변경(일부 필드만 변경이 가능)

<h4>DELETE</h4>
리소스를 제거

----------------------------------------------------------------------------------
<h3>HTTP 메서드의 속성</h3>
안전, 멱등, 캐시가능

<h4>안전 safe</h4>
호출해도 리소스를 변경하지 않는다. -> GET

<h4>멱등 idempotent</h4>
한 번 호출하든 100번 호출하든 결과가 같다. -> GET, PUT, DELETE
GET: 한 번 조회하든 두 번 조회하든 같은 결과가 조회됨
PUT: 결과를 대체함, 같은 요청 여러 번 해도 최종 결과는 같음
DELETE: 결과를 삭제함, 같은 요청을 여러 번 해도 삭제된 결과는 같음

* POST는 여러 번 호출하면 같은 결제가 중복 발생하므로 멱등이 아님
* 활용: 자동 복구 메커니즘: 예를 들어 Delete 호출했는데, 서버에서 응답이 없을 때 클라이언트가 자동으로 요청을 재시도

<h4>캐시 가능 cacheable</h4>
응답 결과 리소스를 캐시해서 사용해도 되는가
GET, HEAD, POST, PATCH 캐시 가능
실제로는 GET HEAD 정도만 캐시로 사용, 나머지는 구현이 어려움

----------------------------------------------------------------------------------
<h3>클라이언트 -> 서버 데이터 전송 방식</h3>
1. 쿼리 파라미터를 통한 데이터 전송
GET, 주로 정렬 필터(검색어)
2. 메시지 바디를 통한 데이터 전송
POST, PUT, PATCH
회원가입, 상품주문, 리소스 등록 및 변경

----------------------------------------------------------------------------------
<h3>HTTP 상태코드</h3>
클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 기능
1xx(Information): 요청이 수신되어 처리 중, 거의 사용하지 않음
2xx(Successful): 요청 정상 처리
3xx(Redirection): 요청 완료를 위해 추가 행동이 필요
4xx(Client Error): 클라이언트 오류, 잘못된 문법 등으로 서버가 요청을 수행할 수 없음
5xx(Server Error): 서버 오류, 서버가 정상 요청을 처리하지 못함

<h4>2xx - 성공</h4>
클라이언트 요청을 성공적으로 처리
200 OK: 요청 성공
201 Created: 요청 성공하여 새로운 리소스 생성됨
202 Accepted: 요청이 접수되었으나 처리가 완료되지 않음(배치 처리)
204 No Content: 서버가 요청을 성공적으로 수행했지만, 응답 페이로드 본문에 보낼 데이터가 없음
(ex. 문서 편집기의 save버튼, 저장버튼을 눌러도 받을 내용이 없음, 204 메시지만으로 저장이 성공했음을 알 수 있음)

<h4>3xx - 리다이렉션</h4>
요청을 완료하기 위해 클라이언트의 추가 조치가 필요
웹 브라우저는 3xx 응답의 결과에 Location 헤더가 있으면 Location 위치로 자동 이동(redirect)
- 영구 리다이렉션: 특정 리소스의 URI가 영구적으로 이동됨(/event -> /new-event)
- 일시 리다이렉션: 일시적인 변경, 주문 완료 후 주문 내역으로 이동(PRG: Post/Redirect/Get)
- 특수 리다이렉션: 결과 대신 캐시를 사용

영구 리다이렉션 - 301, 308
리소스의 URI가 영구적으로 이동, 원래 URI를 사용 X
301 Moved Permanently: 리다이렉션 시 요청 메서드가 GET으로 변하고, 본문이 제거될 수 있다
308 Permanently Redirect: 301과 기능은 같고, 리다이렉트 시 요청 메서드와 본문을 유지함

일시 리다이렉션 - 302, 307, 303
리소스의 URI가 일시적으로 변경, 따라서 검색 엔진 등에서 URL을 변경하면 안됨
302 Found: 리다이렉트 시 요청 메서드가 GET으로 변하고, 본문이 제거될 수 있음
307 Temporary Redirect: 302와 기능은 같고, 리다이렉트 시 요청 메서드와 본문을 유지함
303 See Other: 302와 기능은 같고, 리다이렉트 시 요청 메서드가 GET으로 변경
ex) POST로 주문 후 웹 브라우저를 새로고침 한다면?
새로고침 -> 재요청 -> 중복 주문의 문제가 생김
- PRG(POST/REDIRECT/GET)
POST로 주문 후에 새로고침으로 인한 중복 주문을 방지
POST로 주문 후 주문 결과 화면을 GET으로 리다이렉트
새로고침해도 결과화면을 GET으로 조회
중복주문 대신 결과화면만 GET으로 재요청이 가능함

기타 리다이렉션 - 303, 304
303 Multiple Choice: 안씀
304 Not Modified: 캐시로 리다이렉트
클라이언트에게 리소스가 수정되지 않았음을 알려줌
따라서 클라이언트는 로컬 PC에 저장된 캐시를 재사용
로컬 캐시를 재사용하기 때문에 304응답은 메시지 바디를 포함하지 않음

<h4>4xx - 클라이언트 에러</h4>
클라이언트의 요청에 잘못된 문법 등으로 서버가 요청을 수행할 수 없음
오류 원인이 클라이언트에 있음
클라이언트가 이미 잘못된 요청, 데이터를 보내고 있기 때문에, 같은 재시도는 실패하게 됨 -> 요청을 수정해야 함

401 Unauthorized: 클라이언트가 해당 리소스에 대한 인증이 필요
403 Forbidden: 서버가 요청을 이해했으나 승인을 거부함, 인증 자격 증명은 있지만 접근 권한이 불충분
(Admin이 아닌 사용자가 로그인했지만, Admin 등급의 리소스에 접근하는 경우)
404 Not Found: 요청 리소스를 서버에서 찾을 수 없음

<h4>5xx - 서버 에러</h4>
서버 문제로 오류 발생
서버 문제이므로 재시도하면 성공할 수 있음(서버가 복구되는 등)

500 Internal Server Error: 서버 문제로 오류 발생, 애매하면 모두 500을 내보냄
503 Service Unavailable: 서버가 일시적인 과부하 또는 예정 작업으로 잠시 요청을 처리할 수 없음
Retry-After 헤더 필드로 얼마 뒤 복구되는지 보낼 수 있음







